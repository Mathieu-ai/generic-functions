/**
 * Lightweight object utility functions
 * No external dependencies
 */

export interface FlatOptions {
  props?: string[];
}

/**
 * Flatten an object and extract values
 * @param data - The data to flatten
 * @param options - Flatten options
 * @param options.props - Array of property names to include (empty array includes all)
 * @returns Flattened string of values joined by commas
 * @example
 * flat({ a: 1, b: { c: 2 } }) // '1, 2'
 * flat({ a: 1, b: { c: 2 } }, { props: ['a'] }) // '1'
 */
export function flat (data: any, options: FlatOptions = {}): string {
  const { props = [] } = options;
  const result: string[] = [];

  const traverse = (obj: any) => {
    for (const key in obj) {
      const val = obj[key];

      if (typeof val === "object" && val) {
        traverse(val);
      } else if (!props.length || props.includes(key)) {
        if (Array.isArray(val)) {
          result.push(...val.filter(item => item));
        } else if (val) {
          result.push(val);
        }
      }
    }
  };

  traverse(data);
  return [...new Set(result)].join(', ');
}

/**
 * Get object keys by value type
 * @param obj - The object to analyze
 * @param type - The type to filter by ('string', 'number', 'boolean', etc.)
 * @returns Array of keys whose values match the specified type
 * @example
 * getObjectKeysByType({ a: 1, b: 'hello', c: true }, 'string') // ['b']
 */
export function getObjectKeysByType (obj: object, type: string): string[] {
  return Object.entries(obj)
    .filter(([_, value]) => typeof value === type)
    .map(([key, _]) => key);
}

/**
 * Get value from object by path
 * @param obj - The object to traverse
 * @param path - Array of keys representing the path to the desired value
 * @returns The value at the specified path or null if not found
 * @example
 * getObjectValueByPath({ a: { b: { c: 42 } } }, ['a', 'b', 'c']) // 42
 * getObjectValueByPath({ items: [{ name: 'John' }, { name: 'Jane' }] }, ['items', 'name']) // ['John', 'Jane']
 */
export function getObjectValueByPath<T> (obj: any, path: string[]): T | null {
  return path.reduce((o, key) => {
    if (o && Array.isArray(o)) {
      return o.map((item) => getObjectValueByPath<T>(item, [key])).flat();
    }
    return (o && o[key]) ? o[key] : null;
  }, obj);
}

/**
 * Check if a value is empty
 * @param value - The value to check (string, object, or array)
 * @param options - Check options
 * @param options.props - If true, checks if all object properties are empty recursively
 * @returns True if the value is considered empty, false otherwise
 * @example
 * isEmpty('') // true
 * isEmpty([]) // true
 * isEmpty({}) // true
 * isEmpty({ a: '' }, { props: true }) // true
 */
export function isEmpty (
  value: string | object | any[],
  options: { props?: boolean } = { props: false }
): boolean {
  switch (typeof value) {
    case "string":
      return value.length === 0;
    case "object":
      if (Array.isArray(value)) {
        return value.every((item) => isEmpty(item, options));
      } else {
        if (options.props) {
          return Object.values(value).every((prop) =>
            isEmpty(prop, options)
          );
        }
        return Object.keys(value).length === 0;
      }
    default:
      return true;
  }
}

/**
 * Gets the type of a value
 * @param value - The value to check
 * @returns The type as a string ('string', 'number', 'object', etc.)
 * @example
 * getValueType('hello') // 'string'
 * getValueType(42) // 'number'
 * getValueType({}) // 'object'
 */
export function getValueType (value: any): string {
  return typeof value;
}

/**
 * Creates an object with the same keys as the input object and values generated by running each property through an iteratee function
 * @param obj - The object to map over
 * @param iteratee - The function invoked per property (value, key) => newValue
 * @returns A new object with transformed values
 * @example
 * mapValues({ a: 1, b: 2 }, x => x * 2) // { a: 2, b: 4 }
 * mapValues({ a: 'hello', b: 'world' }, (value, key) => `${key}: ${value}`) // { a: 'a: hello', b: 'b: world' }
 */
export function mapValues<T, R> (obj: Record<string, T>, iteratee: (value: T, key: string) => R): Record<string, R> {
  const result: Record<string, R> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[key] = iteratee(value, key);
  }
  return result;
}

/**
 * Creates an object with the same values as the input object and keys generated by running each property through an iteratee function
 * @param obj - The object to map over
 * @param iteratee - The function invoked per property (value, key) => newKey
 * @returns A new object with transformed keys
 * @example
 * mapKeys({ a: 1, b: 2 }, (value, key) => key.toUpperCase()) // { A: 1, B: 2 }
 */
export function mapKeys<T> (obj: Record<string, T>, iteratee: (value: T, key: string) => string): Record<string, T> {
  const result: Record<string, T> = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = iteratee(value, key);
    result[newKey] = value;
  }
  return result;
}

/**
 * Creates an object that inherits from the given prototype object
 * @param prototype - The object to inherit from (can be null)
 * @param properties - Optional properties to assign to the new object
 * @returns A new object inheriting from the prototype
 * @example
 * const proto = { greet: () => 'hello' }
 * const obj = create(proto, { name: 'John' }) // obj.greet() works and obj.name === 'John'
 */
export function create<T extends object> (prototype: T | null, properties?: Record<string, any>): T {
  const result = Object.create(prototype);
  if (properties) {
    Object.assign(result, properties);
  }
  return result;
}

/**
 * Assigns own enumerable string keyed properties of source objects to the destination object
 * @param target - The destination object to assign properties to
 * @param sources - The source objects to copy properties from
 * @returns The target object with assigned properties
 * @example
 * assign({ a: 1 }, { b: 2 }, { c: 3 }) // { a: 1, b: 2, c: 3 }
 */
export function assign<T extends Record<string, any>> (target: T, ...sources: Partial<T>[]): T {
  return Object.assign(target, ...sources);
}

/**
 * Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object
 * @param target - The destination object to merge into
 * @param sources - The source objects to merge from
 * @returns The target object with merged properties
 * @example
 * merge({ a: { x: 1 } }, { a: { y: 2 }, b: 3 }) // { a: { x: 1, y: 2 }, b: 3 }
 */
export function merge<T extends Record<string, any>> (target: T, ...sources: any[]): T {
  function isObject (obj: any): obj is Record<string, any> {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
  }

  for (const source of sources) {
    if (isObject(source)) {
      for (const key in source) {
        if (isObject(target[key]) && isObject(source[key])) {
          (target as any)[key] = merge((target as any)[key], source[key]);
        } else {
          (target as any)[key] = source[key];
        }
      }
    }
  }
  return target;
}

/**
 * Like merge except that it accepts a customizer function which is invoked to produce the merged values
 * @param target - The destination object to merge into
 * @param source - The source object to merge from
 * @param customizer - The function to customize assigned values (objValue, srcValue, key) => mergedValue
 * @returns The target object with custom merged properties
 * @example
 * mergeWith({ a: [1] }, { a: [2] }, (obj, src) => Array.isArray(obj) ? obj.concat(src) : undefined) // { a: [1, 2] }
 */
export function mergeWith<T> (target: T, source: any, customizer: (objValue: any, srcValue: any, key: string) => any): T {
  function isObject (obj: any): obj is object {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
  }

  for (const key in source) {
    const objValue = (target as any)[key];
    const srcValue = source[key];
    const result = customizer(objValue, srcValue, key);

    if (result !== undefined) {
      (target as any)[key] = result;
    } else if (isObject(objValue) && isObject(srcValue)) {
      (target as any)[key] = mergeWith(objValue, srcValue, customizer);
    } else {
      (target as any)[key] = srcValue;
    }
  }
  return target;
}

/**
 * Creates an object composed of the picked object properties
 * @param obj - The source object to pick from
 * @param keys - The property keys to pick
 * @returns A new object with only the specified properties
 * @example
 * pick({ a: 1, b: 2, c: 3 }, 'a', 'c') // { a: 1, c: 3 }
 */
export function pick<T extends object, K extends keyof T> (obj: T, ...keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;
  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key];
    }
  }
  return result;
}

/**
 * Creates an object composed of properties that satisfy the predicate function
 * @param obj - The source object to pick from
 * @param predicate - The function invoked per property (value, key) => boolean
 * @returns A new object with properties that pass the predicate test
 * @example
 * pickBy({ a: 1, b: 2, c: 3 }, value => value > 1) // { b: 2, c: 3 }
 */
export function pickBy<T> (obj: Record<string, T>, predicate: (value: T, key: string) => boolean): Partial<Record<string, T>> {
  const result: Partial<Record<string, T>> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Creates an object composed of all properties except the specified ones
 * @param obj - The source object to omit from
 * @param keys - The property keys to omit
 * @returns A new object without the specified properties
 * @example
 * omit({ a: 1, b: 2, c: 3 }, 'a', 'c') // { b: 2 }
 */
export function omit<T, K extends keyof T> (obj: T, ...keys: K[]): Omit<T, K> {
  const result = { ...obj } as any;
  for (const key of keys) {
    delete result[key];
  }
  return result;
}

/**
 * Creates an object composed of properties that do not satisfy the predicate function
 * @param obj - The source object to omit from
 * @param predicate - The function invoked per property (value, key) => boolean
 * @returns A new object with properties that fail the predicate test
 * @example
 * omitBy({ a: 1, b: 2, c: 3 }, value => value > 1) // { a: 1 }
 */
export function omitBy<T> (obj: Record<string, T>, predicate: (value: T, key: string) => boolean): Partial<Record<string, T>> {
  const result: Partial<Record<string, T>> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (!predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Gets the value at the specified path of an object
 * @param obj - The object to query
 * @param path - The path of the property to get (string with dots or array of keys)
 * @param defaultValue - The value returned if the resolved value is undefined
 * @returns The resolved value or default value
 * @example
 * get({ a: { b: { c: 3 } } }, 'a.b.c') // 3
 * get({ a: { b: { c: 3 } } }, ['a', 'b', 'c']) // 3
 * get({}, 'a.b.c', 'default') // 'default'
 */
export function get<T> (obj: any, path: string | string[], defaultValue?: T): T {
  const keys = Array.isArray(path) ? path : path.split('.');
  let result = obj;

  for (const key of keys) {
    if (result == null) break;
    result = result[key];
  }

  return result === undefined ? defaultValue as T : result;
}

/**
 * Sets the value at the specified path of an object
 * @param obj - The object to modify
 * @param path - The path of the property to set (string with dots or array of keys)
 * @param value - The value to set
 * @returns The modified object
 * @example
 * set({}, 'a.b.c', 3) // { a: { b: { c: 3 } } }
 * set({}, ['a', 'b', 'c'], 3) // { a: { b: { c: 3 } } }
 */
export function set<T> (obj: any, path: string | string[], value: T): any {
  const keys = Array.isArray(path) ? path : path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current) || typeof current[key] !== 'object') {
      current[key] = {};
    }
    current = current[key];
  }

  current[keys[keys.length - 1]] = value;
  return obj;
}

/**
 * Checks if the specified path exists as a direct property of the object
 * @param obj - The object to query
 * @param path - The path to check (string with dots or array of keys)
 * @returns True if path exists, false otherwise
 * @example
 * has({ a: { b: { c: 3 } } }, 'a.b.c') // true
 * has({ a: { b: { c: 3 } } }, 'a.b.d') // false
 */
export function has (obj: any, path: string | string[]): boolean {
  const keys = Array.isArray(path) ? path : path.split('.');
  let current = obj;

  for (const key of keys) {
    if (current == null || !(key in current)) {
      return false;
    }
    current = current[key];
  }

  return true;
}

/**
 * Checks if the specified path exists as an own property of the object
 * @param obj - The object to query
 * @param path - The path to check (string with dots or array of keys)
 * @returns True if path exists as own property, false otherwise
 * @example
 * hasIn({ a: { b: 2 } }, 'a.b') // true
 */
export function hasIn (obj: any, path: string | string[]): boolean {
  const keys = Array.isArray(path) ? path : path.split('.');
  let current = obj;

  for (const key of keys) {
    if (current == null || !Object.prototype.hasOwnProperty.call(current, key)) {
      return false;
    }
    current = current[key];
  }

  return true;
}

/**
 * Removes the property at the specified path of an object
 * @param obj - The object to modify
 * @param path - The path of the property to unset (string with dots or array of keys)
 * @returns True if the property is deleted, false otherwise
 * @example
 * const obj = { a: { b: { c: 3 } } }
 * unset(obj, 'a.b.c') // true, obj becomes { a: { b: {} } }
 */
export function unset (obj: any, path: string | string[]): boolean {
  const keys = Array.isArray(path) ? path : path.split('.');
  if (keys.length === 0) return true;

  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    if (current == null || typeof current !== 'object') {
      return true;
    }
    current = current[keys[i]];
  }

  if (current != null && typeof current === 'object') {
    delete current[keys[keys.length - 1]];
    return true;
  }

  return false;
}

/**
 * Creates an array of own enumerable property names of an object
 * @param obj - The object to query
 * @returns An array of property names
 * @example
 * keys({ a: 1, b: 2, c: 3 }) // ['a', 'b', 'c']
 */
export function keys<T> (obj: Record<string, T>): string[] {
  return Object.keys(obj);
}

/**
 * Creates an array of own enumerable property values of an object
 * @param obj - The object to query
 * @returns An array of property values
 * @example
 * values({ a: 1, b: 2, c: 3 }) // [1, 2, 3]
 */
export function values<T> (obj: Record<string, T>): T[] {
  return Object.values(obj);
}

/**
 * Creates an array of own enumerable string keyed-value pairs for an object
 * @param obj - The object to query
 * @returns An array of key-value pairs
 * @example
 * entries({ a: 1, b: 2 }) // [['a', 1], ['b', 2]]
 */
export function entries<T> (obj: Record<string, T>): [string, T][] {
  return Object.entries(obj);
}

/**
 * Creates an array of own and inherited enumerable string keyed-value pairs for an object
 * @param obj - The object to query
 * @returns An array of key-value pairs including inherited properties
 * @example
 * const obj = Object.create({ inherited: 'value' })
 * obj.own = 'property'
 * entriesIn(obj) // [['own', 'property'], ['inherited', 'value']]
 */
export function entriesIn<T> (obj: Record<string, T>): [string, T][] {
  const result: [string, T][] = [];
  for (const key in obj) {
    result.push([key, obj[key]]);
  }
  return result;
}

/**
 * Creates an object from an array of key-value pairs
 * @param pairs - The array of key-value pairs
 * @returns The new object
 * @example
 * fromPairs([['a', 1], ['b', 2]]) // { a: 1, b: 2 }
 */
export function fromPairs<T> (pairs: [string, T][]): Record<string, T> {
  const result: Record<string, T> = {};
  for (const [key, value] of pairs) {
    result[key] = value;
  }
  return result;
}

/**
 * Creates an array of function property names from own enumerable properties of an object
 * @param obj - The object to inspect
 * @returns An array of function property names
 * @example
 * functions({ a: 1, b: () => {}, c: 'string', d: function() {} }) // ['b', 'd']
 */
export function functions (obj: any): string[] {
  return Object.keys(obj).filter(key => typeof obj[key] === 'function');
}

/**
 * Creates an array of function property names from own and inherited enumerable properties of an object
 * @param obj - The object to inspect
 * @returns An array of function property names including inherited ones
 * @example
 * const obj = Object.create({ inheritedFn: () => {} })
 * obj.ownFn = () => {}
 * functionsIn(obj) // ['ownFn', 'inheritedFn']
 */
export function functionsIn (obj: any): string[] {
  const result: string[] = [];
  for (const key in obj) {
    if (typeof obj[key] === 'function') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an object that inverts the keys and values of the input object
 * @param obj - The object to invert
 * @returns The inverted object
 * @example
 * invert({ a: 1, b: 2, c: 1 }) // { '1': 'c', '2': 'b' }
 */
export function invert<T extends Record<string, string | number>> (obj: T): Record<string, string> {
  const result: Record<string, string> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[String(value)] = key;
  }
  return result;
}

/**
 * Creates an inverted object where the inverted keys are generated from running each element through an iteratee
 * @param obj - The object to invert
 * @param iteratee - The iteratee function to transform values into keys
 * @returns The inverted object with arrays of original keys
 * @example
 * invertBy({ a: 1, b: 2, c: 1 }, value => `group${value}`) // { group1: ['a', 'c'], group2: ['b'] }
 */
export function invertBy<T> (obj: Record<string, T>, iteratee: (value: T) => string): Record<string, string[]> {
  const result: Record<string, string[]> = {};
  for (const [key, value] of Object.entries(obj)) {
    const invertedKey = iteratee(value);
    if (!result[invertedKey]) {
      result[invertedKey] = [];
    }
    result[invertedKey].push(key);
  }
  return result;
}

/**
 * Transforms an object by running each own enumerable string keyed property through a transform function
 * @param obj - The object to transform
 * @param transform - The transform function (result, value, key) => void
 * @param accumulator - The initial accumulator value
 * @returns The accumulated result
 * @example
 * transform({ a: 1, b: 2 }, (result, value, key) => { result[key] = value * 2 }, {}) // { a: 2, b: 4 }
 */
export function transform<T, R> (obj: Record<string, T>, transform: (result: R, value: T, key: string) => void, accumulator: R): R {
  const result = accumulator;
  for (const [key, value] of Object.entries(obj)) {
    transform(result, value, key);
  }
  return result;
}

/**
 * Creates a shallow clone of an object
 * @param obj - The object to clone
 * @returns A shallow clone of the object
 * @example
 * const obj = { a: 1, b: { c: 2 } }
 * const cloned = clone(obj) // cloned.b === obj.b (same reference)
 */
export function clone<T> (obj: T): T {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj.getTime()) as any;
  if (Array.isArray(obj)) return obj.slice() as any;
  return Object.assign({}, obj);
}

/**
 * Creates a deep clone of an object
 * @param obj - The object to clone
 * @returns A deep clone of the object
 * @example
 * const obj = { a: 1, b: { c: 2 } }
 * const cloned = cloneDeep(obj) // cloned.b !== obj.b (different reference)
 */
export function cloneDeep<T> (obj: T): T {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj.getTime()) as any;
  if (Array.isArray(obj)) return obj.map(item => cloneDeep(item)) as any;

  const cloned = {} as any;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloned[key] = cloneDeep((obj as any)[key]);
    }
  }
  return cloned;
}

/**
 * Performs a deep comparison between two values to determine if they are equivalent
 * @param a - The first value to compare
 * @param b - The second value to compare
 * @returns True if the values are equivalent, false otherwise
 * @example
 * isEqual([1, 2, 3], [1, 2, 3]) // true
 * isEqual({ a: 1 }, { a: 1 }) // true
 * isEqual({ a: 1 }, { a: 2 }) // false
 */
export function isEqual (a: any, b: any): boolean {
  if (a === b) return true;
  if (a == null || b == null) return a === b;
  if (typeof a !== typeof b) return false;

  if (typeof a === 'object') {
    if (Array.isArray(a) !== Array.isArray(b)) return false;

    if (Array.isArray(a)) {
      if (a.length !== b.length) return false;
      return a.every((item, index) => isEqual(item, b[index]));
    }

    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;

    return keysA.every(key => isEqual(a[key], b[key]));
  }

  return false;
}

/**
 * Checks if an object conforms to a source by invoking predicate properties with corresponding object values
 * @param obj - The object to inspect
 * @param source - The object of predicate functions
 * @returns True if the object conforms, false otherwise
 * @example
 * conformsTo({ a: 1, b: 2 }, { a: n => n > 0, b: n => n < 5 }) // true
 */
export function conformsTo<T> (obj: T, source: Partial<Record<keyof T, (value: any) => boolean>>): boolean {
  for (const key in source) {
    const predicate = source[key];
    if (predicate && !predicate((obj as any)[key])) {
      return false;
    }
  }
  return true;
}

/**
 * Creates a function that invokes the method at a specified path of a given object
 * @param path - The path of the method to invoke
 * @param args - The arguments to invoke the method with
 * @returns A function that takes an object and invokes the method
 * @example
 * const fn = method('toUpperCase')
 * fn('hello') // 'HELLO'
 */
export function method (path: string | string[], ...args: any[]): (obj: any) => any {
  return function (obj: any) {
    const method = get(obj, path);
    return typeof method === 'function' ? method.apply(obj, args) : undefined;
  };
}

/**
 * Creates a function that invokes the method at a given path of the specified object
 * @param obj - The object to query
 * @param args - The arguments to invoke the method with
 * @returns A function that takes a path and invokes the method
 * @example
 * const fn = methodOf('hello world')
 * fn('split') // ['hello', 'world']
 */
export function methodOf (obj: any, ...args: any[]): (path: string | string[]) => any {
  return function (path: string | string[]) {
    const method = get(obj, path);
    return typeof method === 'function' ? method.apply(obj, args) : undefined;
  };
}

/**
 * Assigns properties of source objects to the destination object for all destination properties that resolve to undefined
 * @param obj - The destination object
 * @param sources - The source objects
 * @returns The destination object with default values assigned
 * @example
 * defaults({ a: 1 }, { a: 3, b: 2 }, { c: 3 }) // { a: 1, b: 2, c: 3 }
 */
export function defaults<T extends object> (obj: T, ...sources: Partial<T>[]): T {
  const result = { ...obj };
  for (const source of sources) {
    for (const key in source) {
      if (result[key] === undefined) {
        (result as any)[key] = source[key];
      }
    }
  }
  return result;
}

/**
 * Recursively assigns default properties from source objects to the destination object
 * @param obj - The destination object
 * @param sources - The source objects
 * @returns The destination object with deep default values assigned
 * @example
 * defaultsDeep({ a: { x: 1 } }, { a: { y: 2, x: 3 }, b: 4 }) // { a: { x: 1, y: 2 }, b: 4 }
 */
export function defaultsDeep<T extends object> (obj: T, ...sources: any[]): T {
  function isObject (value: any): value is object {
    return value != null && typeof value === 'object' && !Array.isArray(value);
  }

  const result = cloneDeep(obj);

  for (const source of sources) {
    function assignDefaults (target: any, src: any) {
      for (const key in src) {
        if (target[key] === undefined) {
          target[key] = isObject(src[key]) ? assignDefaults({}, src[key]) : src[key];
        } else if (isObject(target[key]) && isObject(src[key])) {
          assignDefaults(target[key], src[key]);
        }
      }
      return target;
    }
    assignDefaults(result, source);
  }

  return result;
}

/**
 * Gets the values at multiple paths of an object
 * @param obj - The object to query
 * @param paths - The property paths to get values from
 * @returns An array of resolved values
 * @example
 * at({ a: 1, b: { c: 2 } }, 'a', 'b.c', 'missing') // [1, 2, undefined]
 */
export function at<T> (obj: any, ...paths: (string | string[])[]): (T | undefined)[] {
  return paths.map(path => get<T>(obj, path));
}

/**
 * Gets the value at path of object. If the resolved value is a function, it's invoked and its result is returned
 * @param obj - The object to query
 * @param path - The path of the property to get
 * @param defaultValue - The value returned if the resolved value is undefined
 * @returns The resolved value, function result, or default value
 * @example
 * result({ a: () => 42 }, 'a') // 42
 * result({ a: 5 }, 'a') // 5
 */
export function result<T> (obj: any, path: string | string[], defaultValue?: T): T {
  const value = get(obj, path, defaultValue);
  return typeof value === 'function' ? value.call(obj) : value;
}

/**
 * Invokes the method at the specified path of an object
 * @param obj - The object to query
 * @param path - The path of the method to invoke
 * @param args - The arguments to invoke the method with
 * @returns The result of the invoked method
 * @example
 * invoke({ a: { b: Math.max } }, 'a.b', 1, 2, 3) // 3
 */
export function invoke (obj: any, path: string | string[], ...args: any[]): any {
  const method = get(obj, path);
  return typeof method === 'function' ? method.apply(obj, args) : undefined;
}

/**
 * Sets the value at path of object using an updater function
 * @param obj - The object to modify
 * @param path - The path of the property to set
 * @param updater - The function to produce the updated value
 * @returns The modified object
 * @example
 * update({ a: 1 }, 'a', n => n * 2) // { a: 2 }
 */
export function update<T> (obj: any, path: string | string[], updater: (value: any) => T): any {
  const currentValue = get(obj, path);
  const newValue = updater(currentValue);
  return set(obj, path, newValue);
}

/**
 * Like update except that it accepts a customizer which is invoked to produce the updated value
 * @param obj - The object to modify
 * @param path - The path of the property to set
 * @param updater - The function to produce the updated value
 * @param customizer - The function to customize assigned values
 * @returns The modified object
 * @example
 * updateWith({}, 'a.b', () => 'value', () => ({})) // { a: { b: 'value' } }
 */
export function updateWith<T> (obj: any, path: string | string[], updater: (value: any) => T, customizer: (value: any, key: string, object: any) => any): any {
  const keys = Array.isArray(path) ? path : path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    const nextKey = keys[i + 1];

    if (!(key in current) || typeof current[key] !== 'object') {
      current[key] = customizer(undefined, nextKey, current) || {};
    }
    current = current[key];
  }

  const lastKey = keys[keys.length - 1];
  const currentValue = current[lastKey];
  current[lastKey] = updater(currentValue);

  return obj;
}

/**
 * Like set except that it accepts a customizer which is invoked to produce the objects of path
 * @param obj - The object to modify
 * @param path - The path of the property to set
 * @param value - The value to set
 * @param customizer - The function to customize assigned values
 * @returns The modified object
 * @example
 * setWith({}, 'a[0].b.c', 4, Object) // { a: { '0': { b: { c: 4 } } } }
 */
export function setWith<T> (obj: any, path: string | string[], value: T, customizer: (value: any, key: string, object: any) => any): any {
  const keys = Array.isArray(path) ? path : path.split('.');
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    const nextKey = keys[i + 1];

    if (!(key in current) || typeof current[key] !== 'object') {
      current[key] = customizer(undefined, nextKey, current) || {};
    }
    current = current[key];
  }

  current[keys[keys.length - 1]] = value;
  return obj;
}

/**
 * Finds the last key of an object where the predicate returns truthy
 * @param collection - The object to inspect
 * @param predicate - The function invoked per property
 * @returns The key of the matched element, else undefined
 * @example
 * findLastKey({ a: 1, b: 2, c: 3 }, n => n > 1) // 'c'
 */
export function findLastKey<T> (collection: Record<string, T>, predicate: (value: T, key: string, collection: Record<string, T>) => boolean): string | undefined {
  const keys = Object.keys(collection).reverse();
  for (const key of keys) {
    if (predicate(collection[key], key, collection)) {
      return key;
    }
  }
  return undefined;
}

/**
 * Iterates over own and inherited enumerable string keyed properties of an object
 * @param obj - The object to iterate over
 * @param iteratee - The function invoked per property
 * @returns The original object
 * @example
 * forIn({ a: 1, b: 2 }, (value, key) => console.log(key, value))
 */
export function forIn<T> (obj: Record<string, T>, iteratee: (value: T, key: string) => void): Record<string, T> {
  for (const key in obj) {
    iteratee(obj[key], key);
  }
  return obj;
}

/**
 * Like forIn except that it iterates over properties in the opposite order
 * @param obj - The object to iterate over
 * @param iteratee - The function invoked per property
 * @returns The original object
 * @example
 * forInRight({ a: 1, b: 2 }, (value, key) => console.log(key, value)) // logs 'b 2' then 'a 1'
 */
export function forInRight<T> (obj: Record<string, T>, iteratee: (value: T, key: string) => void): Record<string, T> {
  const keys: string[] = [];
  for (const key in obj) {
    keys.push(key);
  }
  for (let i = keys.length - 1; i >= 0; i--) {
    const key = keys[i];
    iteratee(obj[key], key);
  }
  return obj;
}

/**
 * Iterates over own enumerable string keyed properties of an object
 * @param obj - The object to iterate over
 * @param iteratee - The function invoked per property
 * @returns The original object
 * @example
 * forOwn({ a: 1, b: 2 }, (value, key) => console.log(key, value))
 */
export function forOwn<T> (obj: Record<string, T>, iteratee: (value: T, key: string) => void): Record<string, T> {
  for (const [key, value] of Object.entries(obj)) {
    iteratee(value, key);
  }
  return obj;
}

/**
 * Like forOwn except that it iterates over properties in the opposite order
 * @param obj - The object to iterate over
 * @param iteratee - The function invoked per property
 * @returns The original object
 * @example
 * forOwnRight({ a: 1, b: 2 }, (value, key) => console.log(key, value)) // logs 'b 2' then 'a 1'
 */
export function forOwnRight<T> (obj: Record<string, T>, iteratee: (value: T, key: string) => void): Record<string, T> {
  const entries = Object.entries(obj).reverse();
  for (const [key, value] of entries) {
    iteratee(value, key);
  }
  return obj;
}

/**
 * Creates an array of own enumerable string keyed-value pairs for an object (alias for entries)
 * @param obj - The object to query
 * @returns An array of key-value pairs
 * @example
 * toPairs({ a: 1, b: 2 }) // [['a', 1], ['b', 2]]
 */
export function toPairs<T> (obj: Record<string, T>): [string, T][] {
  return entries(obj);
}

/**
 * Creates an array of own and inherited enumerable string keyed-value pairs for an object (alias for entriesIn)
 * @param obj - The object to query
 * @returns An array of key-value pairs including inherited properties
 * @example
 * const obj = Object.create({ inherited: 'value' })
 * obj.own = 'property'
 * toPairsIn(obj) // [['own', 'property'], ['inherited', 'value']]
 */
export function toPairsIn<T> (obj: Record<string, T>): [string, T][] {
  return entriesIn(obj);
}
